# Filename:		scluster_planet_initializers.txt
# Contributors:	SirBlackAxe, FirePrince

# Don't overwrite planets if:
	# colonizable
	# terraformable
	# good deposit (basic deposits are acceptable but should have lower weight)

# reset_planet = {
# 	reroll_deposits = yes
# 	clear_planet_modifiers = yes
# }
# reroll_planet = {
# 	reroll_deposits = yes
# 	reroll_planet_modifiers = yes
# }

### Interesting features from scripted effects:
# create_broken_fe_outpost = yes

@distance = 50
@base_moon_distance = 10
@jumps = 3
@max_moons = 3

@planet_min_size = 10
@planet_max_size = 25
@moon_min_size = 6
@moon_max_size = 10

@homeworld_min_size = 18
@homeworld_max_size = 24 # 21

@scluster_planet_size_min = 15
@scluster_planet_size_mid = 21
@scluster_planet_size_max = 27

# 20-30 pc_gas_giant
# 14-30 pc_molten
# 12-30 pc_barren
# 12-30 pc_barren_col
# 12-25 pc_toxic
# 10-25 pc_frozen

# 				| enc | min | phy | soc | eng | trd |
#---------------+-----+-----+-----+-----+-----+-----|
# normal star	|  x  |     |  x  |     |     |     |
# special star	|     |     |  x  |     |  x  |     |
#---------------+-----+-----+-----+-----+-----+-----|
# pc_molten		|  x  |  x  |     |     |     |  x  |
# pc_barren		|     |  x  |     |     |     |     |
# pc_barren_cold|     |  x  |     |     |     |     |
# pc_frozen		|     |  x  |     |     |  x  |     |
# pc_toxic		|     |  x  |     |  x  |     |  x  |
# pc_gas_giant	|  x  |     |     |     |  x  |  x  |
#---------------+-----+-----+-----+-----+-----+-----|
# pc_asteroid	|     |  x  |     |     |     |  x  |
# pc_ice_asteroid  x  |     |     |     |     |  x  |
# other asteroids     |     |     |     |     |  x  |
#---------------+-----+-----+-----+-----+-----+-----|
# ruined planet	|     |  x  |     |     |     |     |

# spawn_moon_for_deposit = {
	# switch = {
	# 	trigger = has_planet_flag
	# 	scluster_spawn_energy_moon = {
	# 		solar_system = {
	# 			spawn_planet = {
	# 				class = pc_molten
	# 				location = event_target:new_moon_planet
	# 				orbit_location = yes
	# 				orbit_distance_offset = $DISTANCE$
	# 				orbit_angle_offset = $ANGLE$
	# 				size = random # $SIZE$
	# 				init_effect = {
	# 					clear_deposits = yes
	# 					set_planet_flag = starting_deposit
	# 					set_deposit = $DEPOSIT$
	# 				}
	# 			}
	# 		}
	# 		remove_planet_flag = scluster_spawn_energy_moon
	# 	}
	# 	scluster_spawn_minerals_moon = {
	# 		solar_system = {
	# 			spawn_planet = {
	# 				class = "scluster_rl_uninhabitable_moons"
	# 				location = event_target:new_moon_planet
	# 				orbit_location = yes
	# 				orbit_distance_offset = $DISTANCE$
	# 				orbit_angle_offset = $ANGLE$
	# 				size = random # $SIZE$
	# 				init_effect = {
	# 					clear_deposits = yes
	# 					set_planet_flag = starting_deposit
	# 					set_deposit = $DEPOSIT$
	# 				}
	# 			}
	# 		}
	# 		remove_planet_flag = scluster_spawn_minerals_moon
	# 	}
	# 	scluster_spawn_physics_moon = {
	# 		# Only stars get physics deposits normally
	# 		solar_system = {
	# 			spawn_planet = {
	# 				class = "scluster_rl_uninhabitable_moons"
	# 				location = event_target:new_moon_planet
	# 				orbit_location = yes
	# 				orbit_distance_offset = $DISTANCE$
	# 				orbit_angle_offset = $ANGLE$
	# 				size = random # $SIZE$
	# 				init_effect = {
	# 					clear_deposits = yes
	# 					set_planet_flag = starting_deposit
	# 					add_modifier = {
	# 						modifier = strong_magnetic_field
	# 						days = -1
	# 					}
	# 					set_deposit = $DEPOSIT$
	# 				}
	# 			}
	# 		}
	# 		remove_planet_flag = scluster_spawn_physics_moon
	# 	}
	# 	scluster_spawn_society_moon = {
	# 		solar_system = {
	# 			spawn_planet = {
	# 				class = pc_toxic
	# 				location = event_target:new_moon_planet
	# 				orbit_location = yes
	# 				orbit_distance_offset = $DISTANCE$
	# 				orbit_angle_offset = $ANGLE$
	# 				size = random # $SIZE$
	# 				init_effect = {
	# 					clear_deposits = yes
	# 					set_planet_flag = starting_deposit
	# 					set_deposit = $DEPOSIT$
	# 				}
	# 			}
	# 		}
	# 		remove_planet_flag = scluster_spawn_society_moon
	# 	}
	# 	scluster_spawn_engineering_moon = {
	# 		solar_system = {
	# 			spawn_planet = {
	# 				class = pc_frozen
	# 				location = event_target:new_moon_planet
	# 				orbit_location = yes
	# 				orbit_distance_offset = $DISTANCE$
	# 				orbit_angle_offset = $ANGLE$
	# 				size = random # $SIZE$
	# 				init_effect = {
	# 					clear_deposits = yes
	# 					set_planet_flag = starting_deposit
	# 					set_deposit = $DEPOSIT$
	# 				}
	# 			}
	# 		}
	# 		remove_planet_flag = scluster_spawn_engineering_moon
	# 	}
	# }
# }

scluster_add_deposit_if_possible_effect = {
	if = {
		limit = {
			any_system_planet = {
				NOR = {
					has_planet_flag = starting_deposit
					has_planet_flag = ignore_startup_effect
				}
				scluster_can_have_$RESOURCE$_deposits = yes
			}
		}
		random_system_planet = {
			limit = {
				NOR = {
					has_planet_flag = starting_deposit
					has_planet_flag = ignore_startup_effect
				}
				scluster_can_have_$RESOURCE$_deposits = yes
			}
			set_planet_flag = starting_deposit
			set_planet_flag = starting_$RESOURCE$_deposit
			add_deposit = d_$RESOURCE$_$SIZE$
		}
	}
	else_if = {
		limit = {
			any_system_planet = {
				NOR = {
					has_planet_flag = starting_deposit
					has_planet_flag = ignore_startup_effect
				}
				has_deposit = no
				is_star = no
				is_asteroid = no
			}
		}
		random_system_planet = {
			limit = {
				NOR = {
					has_planet_flag = starting_deposit
					has_planet_flag = ignore_startup_effect
				}
				has_deposit = no
			}
			change_pc = scluster_rl_planets_for_$RESOURCE$_deposits
			set_planet_flag = starting_deposit
			set_planet_flag = starting_$RESOURCE$_deposit
			add_deposit = d_$RESOURCE$_$SIZE$
		}
	}
	else_if = {
		limit = {
			any_system_planet = {
				scluster_can_have_$RESOURCE$_deposits = yes
				NOT = { has_planet_flag = ignore_startup_effect }
				OR = {
					# Can stack deposits of the same type
					has_planet_flag = starting_$RESOURCE$_deposit
					# Safe to mix deposits of different types if habitat isn't possible
					is_moon = yes
					is_asteroid = yes
					is_star = yes
				}
			}
		}
		random_system_planet = {
			limit = {
				NOT = { has_planet_flag = ignore_startup_effect }
				scluster_can_have_$RESOURCE$_deposits = yes
				OR = {
					# Can stack deposits of the same type
					has_planet_flag = starting_$RESOURCE$_deposit
					# Safe to mix deposits of different types if habitat isn't possible
					is_moon = yes
					is_asteroid = yes
					is_star = yes
				}
			}
			set_planet_flag = starting_deposit
			set_planet_flag = starting_$RESOURCE$_deposit
			add_deposit = d_$RESOURCE$_$SIZE$
		}
	}
	# else = {
	# 	if = {
	# 		limit = {
	# 			any_system_planet = {
	# 				has_modifier = extensive_moon_system
	# 				num_moons < @max_moons
	# 			}
	# 		}
	# 		ordered_system_planet = {
	# 			limit = { has_modifier = extensive_moon_system }
	# 			position = 0
	# 			order_by = trigger:num_moons
	# 			inverse = yes

	# 			save_event_target_as = new_moon_planet
	# 		}
	# 	}
	# 	else = {
	# 		ordered_system_planet = {
	# 			limit = {
	# 				is_star = no
	# 				is_asteroid = no
	# 				is_moon = no
	# 				is_artificial = no
	# 			}
	# 			position = 0
	# 			order_by = trigger:num_moons
	# 			inverse = yes

	# 			save_event_target_as = new_moon_planet
	# 		}
	# 	}
	# 	event_target:new_moon_planet = {
	# 		set_variable = {
	# 			which = new_moon_distance
	# 			value = 0
	# 		}
	# 		export_trigger_value_to_variable = {
	# 			trigger = num_moons
	# 			variable = new_moon_distance
	# 		}
	# 		multiply_variable = {
	# 			which = new_moon_distance
	# 			value = 10
	# 		}
	# 		set_variable_to_random_value = {
	# 			which = new_moon_size
	# 			min = @moon_min_size
	# 			max = @moon_min_size
	# 			rounded = yes
	# 		}
	# 		set_variable_to_random_value = {
	# 			which = new_moon_angle
	# 			min = 1
	# 			max = 360
	# 			rounded = yes
	# 		}
	# 		set_planet_flag = scluster_spawn_$RESOURCE$_moon
	# 		spawn_moon_for_deposit = {
	# 			DISTANCE = new_moon_distance
	# 			# SIZE = new_moon_size
	# 			ANGLE = new_moon_angle
	# 			DEPOSIT = d_$RESOURCE$_$SIZE$
	# 		}
	# 		# set_planet_flag = scluster_spawn_energy_moon
	# 		# spawn_moon_for_deposit = { DISTANCE = 10 ANGLE = new_moon_angle DEPOSIT = d_energy_2 }
	# 	}
	# }
}

scluster_generate_home_system_resources = {
	optimize_memory
	every_system_planet = {
		limit = {
			colonizable_planet = no
			NOT = { has_planet_flag = ignore_startup_effect }
			has_anomaly = no
			# Mixed type deposits are safe on anything you can't build a habitat on
			is_star = no
			is_moon = no
			is_asteroid = no
		}
		# prevent_anomaly = yes
		clear_deposits = yes
	}

	system_star = {
		set_planet_flag = starting_deposit
		add_deposit = d_energy_5
	}

	# Research is more restricted, so do that first

	reroll_random = yes
	random_list = {
		33 = { scluster_add_deposit_if_possible_effect = { RESOURCE = society SIZE = 3 } }
		33 = { scluster_add_deposit_if_possible_effect = { RESOURCE = physics SIZE = 3 } }
		33 = { scluster_add_deposit_if_possible_effect = { RESOURCE = engineering SIZE = 3 } }
	}

	reroll_random = yes
	random_list = {
		33 = { scluster_add_deposit_if_possible_effect = { RESOURCE = society SIZE = 2 } }
		33 = { scluster_add_deposit_if_possible_effect = { RESOURCE = physics SIZE = 2 } }
		33 = { scluster_add_deposit_if_possible_effect = { RESOURCE = engineering SIZE = 2 } }
	}

	# Energy

	random_system_planet = {
		limit = {
			NOR = {
				has_planet_flag = starting_deposit
				has_planet_flag = ignore_startup_effect
			}
			scluster_can_have_energy_deposits = yes
		}

		set_planet_flag = starting_deposit
		add_deposit = d_energy_5
	}

	random_system_planet = {
		limit = {
			NOR = {
				has_planet_flag = starting_deposit
				has_planet_flag = ignore_startup_effect
			}
			scluster_can_have_energy_deposits = yes # adds pc_ice_asteroid, pc_m_giant_star
		}

		set_planet_flag = starting_deposit
		reroll_random = yes
		random_list = {
			50 = { add_deposit = d_energy_2 }
			50 = { add_deposit = d_energy_3 }
		}
	}

	# Minerals have the most pc options, so add those last

	set_variable = {
		which = total_system_minerals
		value = 0
	}
	while = {
		count = 2
		if = {
			limit = {
				any_system_planet = {
					OR = {
						has_modifier = chthonian_planet
						has_modifier = carbon_world
					}
					NOR = {
						has_planet_flag = starting_deposit
						has_planet_flag = ignore_startup_effect
					}
				}
			}
			random_system_planet = {
				limit = {
					OR = {
						has_modifier = chthonian_planet
						has_modifier = carbon_world
					}
					NOR = {
						has_planet_flag = starting_deposit
						has_planet_flag = ignore_startup_effect
					}
				}
				set_planet_flag = starting_deposit
				add_deposit = d_minerals_6
			}
			change_variable = { which = total_system_minerals value = 6 }
		}
		else_if = {
			limit = {
				check_variable = { which = total_system_minerals value = 6 }
			}
			scluster_add_deposit_if_possible_effect = {
				RESOURCE = minerals
				SIZE = 4
			}
			change_variable = { which = total_system_minerals value = 4 }
		}
		else = {
			random_system_planet = {
				limit = {
					NOR = {
						has_planet_flag = starting_deposit
						has_planet_flag = ignore_startup_effect
					}
					scluster_can_have_minerals_deposits = yes # Adds molten, removes ice_asteroid and crystal_asteroid
				}

				set_planet_flag = starting_deposit
				add_deposit = d_minerals_5
			}
			scluster_add_deposit_if_possible_effect = {
				RESOURCE = minerals
				SIZE = 5
			}
			change_variable = { which = total_system_minerals value = 5 }
		}
	}
	every_system_planet = {
		limit = {
			has_modifier = chthonian_planet
			NOR = {
				has_planet_flag = starting_deposit
				has_planet_flag = ignore_startup_effect
			}
		}
		remove_modifier = chthonian_planet
	}
	every_system_planet = {
		limit = {
			has_modifier = carbon_world
			NOR = {
				has_planet_flag = starting_deposit
				has_planet_flag = ignore_startup_effect
			}
		}
		remove_modifier = carbon_world
	}

	random_system_planet = {
		limit = {
			NOR = {
				has_planet_flag = starting_deposit
				has_planet_flag = ignore_startup_effect
			}
			scluster_can_have_minerals_deposits = yes # Adds molten, removes asteroid variants
		}

		set_planet_flag = starting_deposit
		reroll_random = yes
		random_list = {
			50 = { add_deposit = d_minerals_2 }
			50 = { add_deposit = d_minerals_3 }
		}
	}

	set_star_flag = scluster_has_home_system_resources
}

# This is called before the pre-ftl species is created due to interactions between various origins and the pop creation effect.
scluster_select_pre_ftl_origin = { # Variant of select_pre_ftl_origin
	# Void Dwellers
	if = {
		limit = { is_planet_class = pc_habitat }
		set_planet_flag = pre_ftl_void_dwellers
	}
	else_if = {
		limit = { is_planet_class = pc_ringworld_habitable }
		# Do nothing!
	}
	else_if = {
		limit = { is_planet_class = pc_shattered_ring_habitable }
		set_planet_flag = pre_ftl_shattered_ring
	}
	else_if = { # Added: If planet is already Gaia, set Life-Seeded (DLC allowing)
		limit = {
			is_planet_class = pc_gaia
			host_has_dlc = "Apocalypse"
			has_first_contact_dlc = yes
		}
		set_planet_flag = pre_ftl_life_seeded
	}
	else = {
		random_list = {
			# Default pre-ftl origin
			# All other origins require First Contact.
			100 = { set_planet_flag = pre_ftl_default }

			# Mechanists (requires Utopia)
			5 = {
				modifier = {
					factor = 0
					OR = {
						has_first_contact_dlc = no
						has_utopia = no
						has_planet_flag = pre_ftl_hive_mind
						any_galaxy_planet = { has_planet_flag = pre_ftl_mechanists }
					}
				}
				set_planet_flag = pre_ftl_mechanists
			}

			# Life-Seeded (requires Apocalypse)
			5 = {
				modifier = {
					factor = 0
					NOT = { host_has_dlc = "Apocalypse" }
				}
				modifier = {
					factor = 0
					OR = {
						has_first_contact_dlc = no
						any_galaxy_planet = { has_planet_flag = pre_ftl_life_seeded }
						any_country = { has_origin = origin_life_seeded }
					}
				}
				set_planet_flag = pre_ftl_life_seeded
				change_pc = pc_gaia
				create_life_seeded_planet = yes
			}

			# Ocean Paradise (Requires Aquatics)
			5 = {
				modifier = {
					factor = 0
					OR = {
						has_aquatics = no
						has_first_contact_dlc = no
					}
				}
				modifier = {
					factor = 0
					OR = {
						any_galaxy_planet = { has_planet_flag = pre_ftl_ocean_paradise }
						any_country = { has_origin = origin_ocean_paradise }
					}
				}
				set_planet_flag = pre_ftl_ocean_paradise
				change_pc = pc_ocean
				set_planet_size = 30
				create_ocean_paradise_planet = yes
			}

			# Subterranean (requires Overlord)
			5 = {
				modifier = {
					factor = 0
					OR = {
						has_overlord_dlc = no
						has_first_contact_dlc = no
						any_galaxy_planet = { has_planet_flag = pre_ftl_subterranean }
					}
				}
				set_planet_flag = pre_ftl_subterranean
			}
		}
	}
}

scluster_init_primitive_system = {
	# generate_pre_ftls_on_planet = {
		# select_pre_ftl_origin = yes # sets a planet_flag
		# create_pre_ftl_species = yes # ensures origin-required traits by planet_flag
		# create_pre_ftl_empire = {
		# 	35:65 create_late:early_pre_ftl_empire = {
		# 		create_country
		# 		set_pre_ftl_age
		# 		set_pre_ftl_origin = {
		# 			switch = has_planet_flag
		# 		}
		# 	}
		# }
		# setup_pre_ftl_planet = yes # sets buildings, pops; create_pre_ftl_blockers if machine_age or later
		# pre_ftl_clean_up_effect = yes # brings origin_subterranean and origin_mechanists up to industrial age
	# }
	if = { # shattered_ring_start -> pre_ftl_shattered_ring
		limit = { has_star_flag = shattered_ring_system }
		random_system_planet = {
			limit = { is_planet_class = "pc_shattered_ring_habitable" }
			save_event_target_as = scluster_pre_ftl_planet

			add_deposit = d_segment_rubble_1
			add_deposit = d_segment_rubble_2
			add_deposit = d_segment_rubble_3
			add_deposit = d_segment_rubble_4
			add_deposit = d_decrepit_tunnels_1
			add_deposit = d_decrepit_tunnels_1
			add_deposit = d_decrepit_tunnels_1
		}
	}
	else_if = { # ocean paradise
		limit = { has_star_flag = ocean_paradise }
		random_system_planet = {
			limit = { has_modifier = ocean_paradise }
			set_planet_flag = pre_ftl_ocean_paradise # normally blocked in generate_pre_ftls_on_planet if an empire or pre-ftl already has this origin
			# create_ocean_paradise_planet
			save_event_target_as = scluster_pre_ftl_planet
		}
	}
	else = {
		random_system_planet = {
			limit = {
				is_colonizable = yes
				has_anomaly = no
				is_preventing_anomaly = no
				NOT = { exists = archaeological_site }
			}
			weights = {
				base = 5
				complex_trigger_modifier = {
					trigger = planet_size
					mode = factor
				}
				modifier = { factor = 2 is_artificial = yes }
			}
			save_event_target_as = scluster_pre_ftl_planet
		}
	}

	if = {
		limit = { NOT = { exists = event_target:scluster_pre_ftl_planet } }
		random_system_planet = {
			limit = {
				uninhabitable_regular_planet = yes
				has_anomaly = no
				is_preventing_anomaly = no
				NOT = { exists = archaeological_site }
				# has_deposit = no
			}
			weights = {
				base = 3
				complex_trigger_modifier = {
					trigger = planet_size
					mode = factor
				}
				modifier = {
					factor = 0.1
					OR = {
						planet_size < @scluster_planet_size_min
						planet_size > 30
					}
				}
			}
			change_pc = "scluster_rl_colonizable_planets"
			reroll_planet = yes
			save_event_target_as = scluster_pre_ftl_planet
		}
	}

	event_target:scluster_pre_ftl_planet = {
		prevent_anomaly = yes
		random_list = {
			26 = { # pre_ftl_init_01
				generate_pre_ftls_on_planet = yes # pre_ftl_scripted_effects.txt
			}
			4 = { # pre_ftl_hive_init_01
				modifier = {
					factor = 0
					OR = {
						has_utopia = no
						has_first_contact_dlc = no
					}
				}
				set_planet_flag = pre_ftl_hive_mind
				generate_pre_ftl_hive_on_planet = yes # pre_ftl_scripted_effects.txt
				if = {
					limit = { has_modifier = ocean_paradise }
					remove_modifier = ocean_paradise
					add_modifier = { modifier = ocean_paradise_hive }
				}
			}
		}
		solar_system = {
			set_star_flag = primitive_system
			if = {
				limit = { NOT = { has_star_flag = scluster_has_home_system_resources } }
				scluster_generate_home_system_resources = yes
			}
		}
	}
}

scluster_relic_world_deposits = {
	# reset_planet = yes
	# clear_deposits = yes
	while = {
		count = 7
		random_deposit = { remove_deposit = yes }
	}
	add_deposit = d_relic_dense_ruins_scluster
	add_deposit = d_collapsed_spire
	add_deposit = d_massive_crevice
	add_deposit = d_shattered_solar_array
	add_deposit = d_flooded_reactor_pits
	add_deposit = d_crumbling_mining_tunnels
	add_deposit = d_relic_metal_boneyard
	# prevent_anomaly = yes
}

scluster_set_planet_to_random_size = {
	set_variable = {
		which = scluster_planet_size_var
		value = 0
	}
	if = {
		limit = {
			check_variable = { which = scluster_planet_size_var value >= $MAX$ }
		}
		set_planet_size = $MAX$
	}
	else = {
		reroll_random = yes
		set_variable_to_random_value = {
			which = scluster_planet_size_var
			min = $MIN$
			max = $MAX$
			rounded = yes
		}
		set_planet_size = scluster_planet_size_var
	}
	clear_variable = scluster_planet_size_var
}
scluster_init_homeworld = {
	# planet size
	if = {
		limit = { planet_size < $MIN_SIZE|15$ }
		# change_planet_size = +1
		if = { # if moon, set size to 2/3rds of host planet
			limit = { exists = orbit }
			orbit = {
				set_variable = { which = scluster_moon_size value = 0 }
				export_trigger_value_to_variable = { trigger = planet_size variable = scluster_moon_size }
				multiply_variable = { which = scluster_moon_size value = 0.67 }
				round_variable = scluster_moon_size
			}
			set_planet_size = orbit.scluster_moon_size
			scluster_set_planet_to_random_size = {
				MIN = @moon_max_size # 10
				MAX = orbit.trigger:planet_size
			}
			while = {
				count = 3
				if = {
					limit = {
						planet_size < @scluster_planet_size_min
						planet_size < orbit.trigger:planet_size
					}
					orbit = {
						if = {
							limit = {
								# OR = {
								# 	planet_size < 25
								# 	AND = {
										planet_size < 30
								# 		OR = {
								# 			is_planet_class = pc_gas_giant
								# 			is_planet_class = pc_molten
								# 			is_planet_class = pc_barren
								# 			is_planet_class = pc_barren_col
								# 		}
								# 	}
								# }
							}
							change_planet_size = 1
						}
					}
					change_planet_size = 1
				}
			}
		}
		else = {
			reroll_random = yes
			set_variable_to_random_value = {
				which = scluster_planet_size
				min = $MIN_SIZE|15$
				max = $MAX_SIZE|27$
				rounded = yes
			}
			set_planet_size = scluster_planet_size
		}
	}
	# if = {
	# 	limit = {
	# 		is_moon = no
	# 		OR = {
	# 			planet_size < $MIN_SIZE|15$
	# 			planet_size > $MAX_SIZE|15$
	# 		}
	# 	}
	# 	reroll_random = yes
	# 	set_variable_to_random_value = {
	# 		which = scluster_planet_size
	# 		rounded = yes
	# 	}
	# 	set_planet_size = scluster_planet_size
	# }
	# else_if = {
	# 	limit = {
	# 		is_moon = yes
	# 		OR = {
	# 			planet_size < $MIN_SIZE|15$
	# 			planet_size > $MAX_SIZE|27$
	# 		}
	# 	}
	# }

	change_pc = {
		class = $CLASS|scluster_rl_colonizable_planets$
		inherit_entity = $inherit_entity|no$
	}
	reroll_planet = yes
}

scluster_planet_init_gatekeeper = {
# pick a random planet
	reroll_random = yes
	random_system_planet = {
		limit = {
			has_deposit = no
			is_colonizable = no
			is_star = no
			is_asteroid = no
			is_artificial = no
			planet_size <= @scluster_planet_size_max
			OR = {
				planet_size >= @scluster_planet_size_min
				is_moon = no
				orbit = { planet_size >= 20 }
			}
			# distance from star
		}
		weights = { add = trigger:planet_size }
# Adjust planet size
		if = {
			limit = { planet_size < @scluster_planet_size_min }
			# change_planet_size = +1
			if = { # if moon, set size to 2/3rds of host planet
				limit = { exists = orbit }
				orbit = {
					export_trigger_value_to_variable = { trigger = planet_size variable = scluster_moon_size }
					multiply_variable = { which = scluster_moon_size value = 0.67 }
					round_variable = scluster_moon_size
				}
				set_planet_size = orbit.scluster_moon_size
			}
			else = {
				reroll_random = yes
				set_variable_to_random_value = { # CWTools: set_variable_to_random_value is unexpected in else
					which = scluster_planet_size
					min = 15 # @scluster_planet_size_min
					max = 27 # @scluster_planet_size_max
					rounded = yes
				}
				set_planet_size = scluster_planet_size
			}
		}
# pick an initializer
		reroll_random = yes
		random_list = {
			# 10 = {
			# 	modifier = {
			# 		factor = 0
			# 		event_target:scluster_0 = { has_star_flag = spawned_ }
			# 	}
			# 	scluster_planet_init_ = yes
			# }
			10 = {
				# bottleneck or wormhole system
				modifier = {
					factor = 0
					event_target:scluster_0 = { has_star_flag = spawned_snowfort }
				}
				scluster_planet_init_snowfort = yes
			}
			# 10 = {
			# 	modifier = {
			# 		factor = 0
			# 		event_target:scluster_0 = { has_star_flag = spawned_stormworld }
			# 	}
			# 	scluster_planet_init_stormworld = yes #
			# }
			# 10 = {
			# 	modifier = {
			# 		factor = 0
			# 		event_target:scluster_0 = { has_star_flag = spawned_ }
			# 	}
			# 	scluster_planet_init_ = yes
			# }
			# 10 = {
			# 	modifier = {
			# 		factor = 0
			# 		event_target:scluster_0 = { has_star_flag = spawned_ }
			# 	}
			# 	scluster_planet_init_ = yes
			# }
			# 10 = {
			# 	modifier = {
			# 		factor = 0
			# 		event_target:scluster_0 = { has_star_flag = spawned_ }
			# 	}
			# 	scluster_planet_init_ = yes
			# }
		# DLC planets
			# 10 = {
			# 	modifier = { # Ecumenopolis + Zombies
			# 		factor = 0
			# 		has_megacorp = no
			# 		has_necroids = no
			# 	}
			# 	modifier = {
			# 		factor = 0
			# 		event_target:scluster_0 = { has_star_flag = spawned_ecumenecropolis }
			# 	}
			# 	scluster_planet_init_ecumenecropolis = yes
			# }
			# 10 = {
			# 	modifier = { # Ecumenopolis + Machine World
			# 		factor = 0
			# 		has_megacorp = no
			# 		has_synthethic_dawn = no
			# 	}
			# 	modifier = {
			# 		factor = 0
			# 		event_target:scluster_0 = { has_star_flag = spawned_ecumachina }
			# 	}
			# 	scluster_planet_init_ecumachina = yes
			# }
		}
	}
}

# scluster_fill_out_district_space = {
	# # set_variable = {
	# # 	which = scluster_district_space
	# # 	value = 5
	# # }
	# # export_modifier_to_variable = {
	# # 	modifier = district_generator_max
	# # 	variable = scluster_district_space
	# # }
	# # export_modifier_to_variable = {
	# # 	modifier = district_mining_max
	# # 	variable = scluster_district_space
	# # }
	# # export_modifier_to_variable = {
	# # 	modifier = district_farming_max
	# # 	variable = scluster_district_space
	# # }
	# # also want the value of any blocked deposits
	# while = {
	# 	planet_size > @\[ value:scluster_max_basic_districts + 5 ]
	# 	add_deposit = random # want this to be able to exceed the normal max 3 blockers. Also, does the randomization take drop_weight into account?
	# }
# }

# This one should be a cold system
# Would like to be able to prevent terraforming from wiping blockers for free
scluster_planet_init_snowfort = {
	set_name = "Snowfort"
	change_pc = pc_arctic # Does not change planetview bg?
	reroll_planet = yes
	clear_deposits = yes
	# clear_planet_modifiers = yes
	prevent_anomaly = yes

	export_trigger_value_to_variable = {
		trigger = planet_size
		variable = num_glaciers
	}
	divide_variable = {
		which = num_glaciers
		value = 3
	}
	multiply_variable = {
		which = num_glaciers
		value = 2
	}
	round_variable = num_glaciers

	add_random_non_blocker_deposit = yes
	add_random_non_blocker_deposit = yes
	while = { # only deposits are massive glaciers
		count = num_glaciers # limit = { free_district_slots > @\[ trigger:planet_size / 3 ] }
		# add_blocker = { type = d_massive_glacier blocked_deposit = random }
		add_random_non_blocker_deposit = yes
		add_blocker = {
			type = d_massive_glacier
			blocked_deposit = random # none (default)/<deposit scope - copies the type to the blocked deposit but any flags or variables are lost>/random
		}
		# Wants to block terraforming
	}
	add_building = building_fortress
	# Archaeology site? what happened here: death by giant snowball impact
	# planet class: ice giant

	set_planet_flag = scluster_snowfort
	solar_system = { set_star_flag = scluster_snowfort_system }
	event_target:scluster_0 = { set_star_flag = snowfort_spawned }
}

# scluster_orbital_ring_relic_world = {}
scluster_planet_init_relic_with_ring = {
	change_pc = pc_relic # Does not change planetview bg?
	reroll_planet = yes
	scluster_relic_world_deposits = yes
	prevent_anomaly = yes

	set_planet_flag = ruined_orbital_ring_planet
	set_planet_flag = scluster_relic_with_ring_planet
	save_event_target_as = scluster_relic_with_ring_planet

	solar_system = {
		set_star_flag = scluster_relic_with_ring_system
		spawn_megastructure = {
			type = "orbital_ring_ruined"
			planet = event_target:scluster_relic_with_ring_planet

			init_effect = {
				create_ambient_object = {
					type = "medium_debris_01_object"
					location = this
				}
				last_created_ambient_object = {
					set_location = {
						target = prev
						distance = 8
						angle = 90
					}
				}
				create_ambient_object = {
					type = "medium_debris_02_object"
					location = this
				}
				last_created_ambient_object = {
					set_location = {
						target = prev
						distance = 3
						angle = 270
					}
				}
			}
		}
	}
	event_target:scluster_0 = { set_star_flag = relic_with_ring_spawned }
}
# scluster_planet_init_ecumenecropolis = {}

# tidally locked -> intentionally tidally locked (via anomaly)

# stormworld: wild_storms + hazardous_weather; system has storm effect
scluster_planet_init_storm_world = {
	if = {
		limit = {
			OR = {
				is_colonizable = no
				NOR = {
					is_planet_class = pc_alpine
					is_planet_class = pc_continental
					is_planet_class = pc_tropical
				}
			}
		}
		# d_tempestous_mountain = pc_tropical, pc_alpine, pc_continental, pc_relic
		random_list = {
			40 = { change_pc = "pc_alpine" }
			30 = { change_pc = "pc_continental" }
			30 = { change_pc = "pc_tropical" }
			# Also allowed on relic & gaia
		}
		reroll_deposits = yes
	}
	clear_planet_modifiers = yes
	prevent_anomaly = yes
	add_modifier = { modifier = wild_storms }
	add_modifier = { modifier = hazardous_weather }
	set_planet_name = "Storm World"

	add_deposit = d_tempestous_mountain
	add_deposit = d_betharian_deposit
	every_deposit = {
		limit = {
			is_blocker = no
			NOR = {
				has_deposit_category = deposit_cat_rare
				is_deposit_type = d_tempestous_mountain
			}
		}
		reroll_random = yes
		random = {
			chance = 33
			planet = { add_deposit = d_tempestous_mountain }
			remove_deposit = yes
		}
	}

	set_planet_flag = scluster_storm_world
	solar_system = { set_star_flag = scluster_storm_world_system }
	event_target:scluster_0 = { set_star_flag = storm_world_spawned }
}
# deathworld: unstable_tectonics + Hostile Fauna + Wild Storms = +20% all reasearch, -25% habitability, -15% happiness
scluster_planet_init_deadly_world = {
	# Not Gaia
	set_planet_name = "Danger Zone"
	if = {
		limit = {
			OR = {
				is_colonizable = no
				is_ideal = yes
			}
		}
		change_pc = "rl_habitable_normal"
		reroll_deposits = yes
	}
	clear_planet_modifiers = yes
	prevent_anomaly = yes
	add_modifier = { modifier = wild_storms }
	add_modifier = { modifier = dangerous_wildlife }
	add_modifier = { modifier = unstable_tectonics }

	set_planet_flag = scluster_deadly_world
	solar_system = { set_star_flag = scluster_deadly_world_system }
	event_target:scluster_0 = { set_star_flag = deadly_world_spawned }
}
# asteroid belt + asteroid impacts + high quality minerals = +30% minerals, +9 mining districts, -5% habitability
scluster_planet_init_good_mining_planet = {
	set_planet_name = "Motherlode"
	if = {
		limit = { is_colonizable = no }
		change_pc = "rl_habitable_normal"
		reroll_deposits = yes
	}
	clear_planet_modifiers = yes
	prevent_anomaly = yes
	add_modifier = { modifier = "asteroid_impacts" }
	add_modifier = { modifier = "asteroid_belt" } # Normally x0 if is_moon or has_moon
	random_list = {
		10 = { add_modifier = { modifier = "mineral_rich" } }
		1 = { add_modifier = { modifier = "ultra_rich" } }
	}
	# Motes (dry): d_dust_caverns, d_dust_desert
	# Gas (Wet): d_bubbling_swamp, d_fuming_bog
	# Crystals (Cold): d_crystalline_caverns, d_crystal_forest, d_crystal_reef(ocean/nuked/gaia)

	set_planet_flag = scluster_good_mining_planet
	solar_system = { set_star_flag = scluster_good_mining_planet_system }
	event_target:scluster_0 = { set_star_flag = good_mining_planet_spawned }
}
# atmospheric_aphrodisiac + atmospheric_hallucinogen
# zen world
# predatory plants + Hostile Fauna = +30% society, -20% habitability, -5% happiness
# good habitat system: many non-moon planets with tiny energy/minerals/research deposits, some (esp. w/ minerals) with SR deposits
# good consecration system (tiny gaias w/o rare deposits)

# Festering Hive (of scum and villainy)

### Features
# miners produce fewer minerals but extra trade value
	# planet_miners_trade_value_produces_add
# fossil deposit: terraforming candidate or tomb world w/ special project to resurrect species from dna, possible outcomes are titanic life, dangerous wildlife, [...]
# gemstone deposit

scluster_planet_init_life_seeded = {
	change_pc = pc_arctic # Does not change planetview bg.
	reroll_planet = yes
	clear_deposits = yes
	# clear_planet_modifiers = yes
	set_planet_flag = scluster_life_seeded_planet

	set_planet_size = 30

	# 5 + 3 energy
	add_deposit = d_searing_desert
	add_deposit = d_underwater_vent
	add_deposit = d_tempestous_mountain

	# 5 + 3 mining
	add_deposit = d_ore_rich_caverns
	add_deposit = d_prosperous_mesa
	add_deposit = d_submerged_ore_veins

	# 5 + 3 farming (lithoids swap 3 for minerals)
	add_deposit = d_lush_jungle
	add_deposit = d_teeming_reef

	reroll_random = yes
	random_list = {
		10 = { add_deposit = d_rich_mountain } # limit = { owner = { is_lithoid_empire = yes } }
		90 = { add_deposit = d_black_soil }
	}

	# 1 random medium deposit
	reroll_random = yes
	random_list = {
		33 = { add_deposit = d_frozen_gas_lake }
		33 = { add_deposit = d_prosperous_mesa }
		33 = { add_deposit = d_fertile_lands }
	}

	add_deposit = d_dust_caverns
	add_deposit = d_bubbling_swamp
	add_deposit = d_crystalline_caverns
}

scluster_planet_init_remnants = {
	change_pc = pc_relic # Does not change planetview bg.
	reroll_planet = yes
	clear_deposits = yes
	# clear_planet_modifiers = yes
	set_planet_flag = scluster_remnants_planet

	set_planet_size = 22

	# 5 blockers
	add_deposit = d_ruined_arcology
	add_deposit = d_ruined_arcology
	add_deposit = d_ruined_arcology
	add_deposit = d_ruined_arcology
	add_deposit = d_ruined_arcology

	# 3 + 3 energy
	add_deposit = d_arid_highlands
	add_deposit = d_searing_desert
	add_deposit = d_geothermal_vent
	# if = {
	# 	limit = { owner = { is_machine_empire = yes } }
	# 	add_deposit = d_searing_desert
	# }
	# if = {
	# 	limit = { owner = { has_valid_civic = civic_machine_servitor } }
	# 	add_deposit = d_arid_highlands
	# }

	# 3 + 3 mining
	add_deposit = d_mineral_fields
	add_deposit = d_prosperous_mesa
	add_deposit = d_submerged_ore_veins

	# 4 + 3 farming
	add_deposit = d_bountiful_plains
	add_deposit = d_fertile_lands
	# if = {
	# 	limit = { owner = { is_machine_empire = no } }
		add_deposit = d_bountiful_plains
		add_deposit = d_black_soil
	# }
}

scluster_planet_init_post_apocalyptic = {
	change_pc = pc_nuked # Does not change planetview bg.
	reroll_planet = yes
	clear_deposits = yes
	# clear_planet_modifiers = yes
	set_planet_flag = scluster_post_apocalyptic_planet

	add_deposit = d_tomb_world_ruins
	add_deposit = d_tomb_world_wasteland

	# 3 + 3 energy
	add_deposit = d_hot_springs
	add_deposit = d_searing_desert
	add_deposit = d_underwater_vent

	# 3 + 4 mining
	add_deposit = d_veiny_cliffs
	add_deposit = d_ore_rich_caverns
	add_deposit = d_submerged_ore_veins

	# 3 + 2 farming
	add_deposit = d_lichen_fields
	add_deposit = d_fungal_caves
	add_deposit = d_fungal_forest
}

# hyper-relay?
